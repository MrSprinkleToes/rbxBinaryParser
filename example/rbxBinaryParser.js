/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ var __webpack_modules__ = ({

/***/ "./src/ChunkReader.js":
/*!****************************!*\
  !*** ./src/ChunkReader.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ReadChunk)\n/* harmony export */ });\n/* harmony import */ var _lz4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lz4 */ \"./src/lz4.js\");\n// Chunk:\r\n// Signature: [4]uint8 - Type of chunk and structure of data\r\n// CompressedLength: uint32 - Length of the data\r\n// UncompressedLength: uint32 - Length of the data after decompression\r\n// Reserved: [4]uint8 - Reserved for future use\r\n// Data: []uint8 - The data\r\n// Chunks are compressed using LZ4\r\n// If the chunk is not compressed, CompressedLength == 0 and UncompressedLength == the length of the data\r\n\r\n// var lz4 = require(\"lz4js\");\r\n\r\n\r\n/**\r\n * Reads a chunk of data\r\n * @param {DataView} chunk\r\n */\r\nfunction ReadChunk(data, offset) {\r\n\tconst signature = [\r\n\t\tString.fromCharCode(data.getUint8(offset + 0)),\r\n\t\tString.fromCharCode(data.getUint8(offset + 1)),\r\n\t\tString.fromCharCode(data.getUint8(offset + 2)),\r\n\t\tString.fromCharCode(data.getUint8(offset + 3)),\r\n\t].join(\"\");\r\n\r\n\tconst compressedLength = data.getUint32(offset + 4, true);\r\n\tconst uncompressedLength = data.getUint32(offset + 8, true);\r\n\tconst dataLength =\r\n\t\tcompressedLength == 0 ? uncompressedLength : compressedLength;\r\n\r\n\t// might be incorrectly copying the chunk payload?\r\n\tconst chunkData = new Uint8Array(dataLength);\r\n\tfor (var i = 0; i < dataLength; i++) {\r\n\t\tchunkData[i] = data.getUint8(offset + 16 + i);\r\n\t}\r\n\r\n\tvar payload;\r\n\t// Decompress the data if it is compressed\r\n\tif (compressedLength != 0) {\r\n\t\tpayload = _lz4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].prototype.decodeBlock(\r\n\t\t\tchunkData,\r\n\t\t\t0,\r\n\t\t\tuncompressedLength\r\n\t\t);\r\n\t} else {\r\n\t\tpayload = chunkData;\r\n\t}\r\n\r\n\treturn {\r\n\t\tsignature,\r\n\t\tcompressedLength,\r\n\t\tuncompressedLength,\r\n\t\tdataLength,\r\n\t\tpayload,\r\n\t};\r\n}\r\n\n\n//# sourceURL=webpack://rbxbinaryparser/./src/ChunkReader.js?");

/***/ }),

/***/ "./src/binaryTypeReader.js":
/*!*********************************!*\
  !*** ./src/binaryTypeReader.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ReadPropertyValue\": () => (/* binding */ ReadPropertyValue),\n/* harmony export */   \"ReadReferences\": () => (/* binding */ ReadReferences),\n/* harmony export */   \"ReadString\": () => (/* binding */ ReadString)\n/* harmony export */ });\n// String:\r\n// Length: uint32 - Length of the string\r\n// Bytes: []uint8 - The string\r\n\r\n// References: []zint32b~4\r\n// Difference-encoded array of zigzag-encoded interleaved integers\r\n// Before encoding to bytes, values in the References array are difference-encoded\r\n// such that the current value is added to the previous value to get the actual value.\r\n\r\nconst valueTypes = {\r\n\t0x01: \"String\",\r\n\t0x02: \"Bool\",\r\n\t0x03: \"Int\",\r\n\t0x04: \"Float\",\r\n\t0x05: \"Double\",\r\n\t0x06: \"Udim\",\r\n\t0x07: \"Udim2\",\r\n\t0x08: \"Ray\",\r\n\t0x09: \"Faces\",\r\n\t0x0a: \"Axes\",\r\n\t0x0b: \"BrickColor\",\r\n\t0x0c: \"Color3\",\r\n\t0x0d: \"Vector2\",\r\n\t0x0e: \"Vector3\",\r\n\t0x0f: \"Vector2int16\",\r\n\t0x10: \"CFrame\",\r\n\t0x11: \"CFrameQuat\",\r\n\t0x12: \"Token\",\r\n\t0x13: \"Reference\",\r\n\t0x14: \"Vector3int16\",\r\n\t0x15: \"NumberSequence\",\r\n\t0x16: \"ColorSequence\",\r\n\t0x17: \"NumberRange\",\r\n\t0x18: \"Rect\",\r\n\t0x19: \"PhysicalProperties\",\r\n\t0x1a: \"Color3uint8\",\r\n\t0x1b: \"Int64\",\r\n\t0x1c: \"SharedString\",\r\n\t0x1d: null,\r\n\t0x1e: \"Optional\",\r\n\t0x1f: \"UniqueId\",\r\n\t0x20: \"Font\",\r\n};\r\n\r\nfunction interleaveUint32(data, offset, itemCount, callbackFn) {\r\n\tconst results = new Array(itemCount);\r\n\tconst byteTotal = itemCount * 4;\r\n\r\n\tfor (let i = 0; i < itemCount; i++) {\r\n\t\tlet val = data.getUint8(offset + i) << 24;\r\n\t\tval += data.getUint8(offset + ((i + itemCount) % byteTotal)) << 16;\r\n\t\tval += data.getUint8(offset + ((i + itemCount * 2) % byteTotal)) << 8;\r\n\t\tval += data.getUint8(offset + ((i + itemCount * 3) % byteTotal));\r\n\r\n\t\tif (callbackFn) {\r\n\t\t\tresults[i] = callbackFn(val);\r\n\t\t} else {\r\n\t\t\tresults[i] = val;\r\n\t\t}\r\n\t}\r\n\r\n\treturn results;\r\n}\r\n\r\nfunction interleaveInt32(data, offset, itemCount) {\r\n\treturn interleaveUint32(data, offset, itemCount, (val) =>\r\n\t\tval % 2 === 1 ? -(val + 1) / 2 : val / 2\r\n\t);\r\n}\r\n\r\nfunction ReadString(data, offset) {\r\n\tvar length = data.getUint32(offset, true);\r\n\tvar str = \"\";\r\n\r\n\tfor (let i = 0; i < length; i++) {\r\n\t\tstr += String.fromCharCode(data.getUint8(offset + 4 + i));\r\n\t}\r\n\r\n\treturn [str, length];\r\n}\r\n\r\nfunction ReadReferences(data, offset, length) {\r\n\treturn interleaveInt32(data, offset, length);\r\n}\r\n\r\nfunction float(longNum) {\r\n\tconst exponent = longNum >>> 24;\r\n\tif (exponent === 0) {\r\n\t\treturn 0;\r\n\t}\r\n\tconst floatNum =\r\n\t\t2 ** (exponent - 127) * (1 + ((longNum >>> 1) & 0x7fffff) / 0x7fffff);\r\n\treturn longNum & 1 ? -floatNum : floatNum;\r\n}\r\n\r\nfunction interleaveFloat(data, offset, itemCount) {\r\n\treturn interleaveUint32(data, offset, itemCount, (val) => float(val));\r\n}\r\n\r\nfunction ReadPropertyValue(data, offset, instCount) {\r\n\tconst typeId = data.getUint8(offset);\r\n\tconst type = valueTypes[typeId];\r\n\r\n\tvar values = [];\r\n\tswitch (type) {\r\n\t\tcase \"String\":\r\n\t\t\tvar off = 0;\r\n\t\t\tfor (let i = 0; i < instCount; i++) {\r\n\t\t\t\tconst [str, len] = ReadString(data, offset + 1 + off);\r\n\t\t\t\tvalues[i] = str;\r\n\t\t\t\toff += len + 4;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase \"Bool\":\r\n\t\t\tfor (let i = 0; i < instCount; i++) {\r\n\t\t\t\tvalues[i] = data.getUint8(offset + 1 + i) === 1;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase \"Int\":\r\n\t\t\t// is encoded as zint32b~4\r\n\t\t\tvalues = interleaveInt32(data, offset + 1, instCount);\r\n\t\t\tbreak;\r\n\t\tcase \"Float\":\r\n\t\t\t// is encoded as rfloat32b~4\r\n\t\t\tvalues = interleaveFloat(data, offset + 1, instCount);\r\n\t\t\tbreak;\r\n\t\tcase \"Double\":\r\n\t\t\t// TODO: implement\r\n\t\t\tbreak;\r\n\t\tcase \"UDim\":\r\n\t\t\t// TODO: implement\r\n\t\t\tbreak;\r\n\t\tcase \"UDim2\":\r\n\t\t\t// TODO: implement\r\n\t\t\tbreak;\r\n\t\tcase \"Ray\":\r\n\t\t\t// TODO: implement\r\n\t\t\tbreak;\r\n\t\tcase \"Faces\":\r\n\t\t\t// TODO: implement\r\n\t\t\tbreak;\r\n\t\tcase \"Axes\":\r\n\t\t\t// TODO: implement\r\n\t\t\tbreak;\r\n\t\tcase \"BrickColor\":\r\n\t\t\t// TODO: implement\r\n\t\t\tbreak;\r\n\t\tcase \"Color3\":\r\n\t\t\t// TODO: implement\r\n\t\t\tbreak;\r\n\t\tcase \"Vector2\":\r\n\t\t\t// TODO: implement\r\n\t\t\tbreak;\r\n\t\tcase \"Vector3\":\r\n\t\t\tconst x = interleaveFloat(data, offset + 1, instCount);\r\n\t\t\tconst y = interleaveFloat(data, offset + 1 + instCount * 4, instCount);\r\n\t\t\tconst z = interleaveFloat(data, offset + 1 + instCount * 8, instCount);\r\n\r\n\t\t\tfor (let i = 0; i < instCount; i++) {\r\n\t\t\t\tvalues[i] = { x: x[i], y: y[i], z: z[i] };\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tvalues = null;\r\n\t}\r\n\r\n\treturn {\r\n\t\ttype,\r\n\t\tvalues,\r\n\t};\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://rbxbinaryparser/./src/binaryTypeReader.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"decode\": () => (/* binding */ decode)\n/* harmony export */ });\n/* harmony import */ var _binaryTypeReader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./binaryTypeReader */ \"./src/binaryTypeReader.js\");\n/* harmony import */ var _ChunkReader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ChunkReader */ \"./src/ChunkReader.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ \"./src/util.js\");\n\r\n\r\n\r\n\r\n// Decoding roblox binary files\r\n// Starts with a signature of type [14]uint8\r\n// Then a version of type uint16\r\n// Then the content\r\n\r\n// Header:\r\n// ClassCount: uint32 - The number of unique classes in the file\r\n// InstanceCount: uint32 - The number of instances in the file\r\n// Reserved: [8]uint8 - Reserved for future use\r\n\r\n// Chunk:\r\n// Signature: [4]uint8 - Type of chunk and structure of data\r\n// CompressedLength: uint32 - Length of the data\r\n// UncompressedLength: uint32 - Length of the data after decompression\r\n// Reserved: [4]uint8 - Reserved for future use\r\n// Data: []uint8 - The data\r\n// Chunks are compressed using LZ4\r\n// If the chunk is not compressed, CompressedLength == 0 and UncompressedLength == the length of the data\r\n\r\n// Chunks:\r\n// META:\r\n// Length: uint32 - The amount of entries\r\n// Entries: []Entry\r\n// Entry:\r\n// Key: string - The key of the entry\r\n// Value: string - The value of the entry\r\n\r\n// SSTR:\r\n// Version: int32 - The version of the chunk\r\n// Length: uint32 - The amount of strings\r\n// Strings: []SharedStringValue - The strings\r\n// SharedStringValue:\r\n// Hash: [16]uint8 - The hash of the string\r\n// Value: string - The value of the string\r\n\r\n// INST:\r\n// ClassID: int32 - The class ID of the instance\r\n// ClassName: string - The name of the class\r\n// HasService: bool - Whether the chunk has service data\r\n// Length: uint32 - The amount of instances\r\n// IDs: References - The instances\r\n// IsService: ?[]bool - Whether the instance is a service\r\n\r\nconst signature = [\r\n\t0x3c, 0x72, 0x6f, 0x62, 0x6c, 0x6f, 0x78, 0x21, 0x89, 0xff, 0x0d, 0x0a, 0x1a,\r\n\t0x0a,\r\n];\r\nconst signatureLength = 14;\r\n\r\nfunction decode(buffer) {\r\n\tconst start = performance.now();\r\n\tconst data = new DataView(buffer);\r\n\r\n\t// Get the position of the signature (might not be 0)\r\n\tvar sigPos = 0;\r\n\tfor (var i = 0; i < buffer.length; i++) {\r\n\t\tif (data.getUint8(i) == signature[0]) {\r\n\t\t\tsigPos = i;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\t// Get the signature\r\n\tvar sig = [];\r\n\tfor (var i = 0; i < signatureLength; i++) {\r\n\t\tsig.push(data.getUint8(i + sigPos));\r\n\t}\r\n\r\n\tconsole.assert((0,_util__WEBPACK_IMPORTED_MODULE_2__.arraysEqual)(sig, signature), \"Invalid file signature.\");\r\n\tconsole.log(\"Valid file signature.\");\r\n\r\n\t// Get the version\r\n\tvar versionPos = sigPos + signatureLength;\r\n\tvar version = data.getUint16(versionPos, true);\r\n\tconsole.log(\"Version:\", version);\r\n\r\n\tvar headerPos = versionPos + 2;\r\n\tvar header = {\r\n\t\tclassCount: data.getUint32(headerPos, true),\r\n\t\tinstanceCount: data.getUint32(headerPos + 4, true),\r\n\t};\r\n\tconsole.log(\"Header:\", header);\r\n\r\n\t// for each chunk get the signature, compressed length, uncompressed length, and data using ReadChunk(chunk: ArrayBuffer)\r\n\tvar chunkPos = headerPos + 16;\r\n\tvar chunk = {};\r\n\tvar instances = [];\r\n\tvar classes = [];\r\n\tvar output = [];\r\n\twhile (chunkPos < buffer.byteLength && chunk.signature !== \"END\\x00\") {\r\n\t\tchunk = (0,_ChunkReader__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(data, chunkPos);\r\n\t\t// console.log(\"Chunk:\", chunk);\r\n\t\tchunkPos += 16 + chunk.dataLength;\r\n\r\n\t\tconst payload = new DataView(chunk.payload.buffer);\r\n\r\n\t\tif (chunk.signature == \"META\") {\r\n\t\t\tconst arrayLength = payload.getUint32(0, true);\r\n\t\t\tconst entries = [];\r\n\r\n\t\t\tvar offset = 4;\r\n\t\t\tfor (let i = 0; i < arrayLength; i++) {\r\n\t\t\t\tconst [key, keyLength] = (0,_binaryTypeReader__WEBPACK_IMPORTED_MODULE_0__.ReadString)(payload, offset);\r\n\t\t\t\toffset += keyLength + 4;\r\n\t\t\t\tconst [value, valueLength] = (0,_binaryTypeReader__WEBPACK_IMPORTED_MODULE_0__.ReadString)(payload, offset);\r\n\t\t\t\toffset += valueLength + 4;\r\n\r\n\t\t\t\tentries.push({ key, value });\r\n\t\t\t}\r\n\r\n\t\t\t// console.log(\"META length:\", arrayLength);\r\n\t\t\t// console.log(\"META entries:\", entries);\r\n\t\t} else if (chunk.signature == \"SSTR\") {\r\n\t\t\t// SSTR is currently unused\r\n\t\t} else if (chunk.signature == \"INST\") {\r\n\t\t\tconst classId = payload.getInt32(0, true);\r\n\t\t\tconst [className, classNameLength] = (0,_binaryTypeReader__WEBPACK_IMPORTED_MODULE_0__.ReadString)(payload, 4);\r\n\t\t\tconst hasService = payload.getUint8(4 + 4 + classNameLength, true);\r\n\t\t\tconst instLength = payload.getUint32(4 + 4 + classNameLength + 1, true);\r\n\t\t\tconst instIds = (0,_binaryTypeReader__WEBPACK_IMPORTED_MODULE_0__.ReadReferences)(\r\n\t\t\t\tpayload,\r\n\t\t\t\t4 + 4 + classNameLength + 1 + 4,\r\n\t\t\t\tinstLength\r\n\t\t\t);\r\n\t\t\tconst isService = [];\r\n\t\t\tfor (let i = 0; i < instLength; i++) {\r\n\t\t\t\tisService.push(\r\n\t\t\t\t\tpayload.getUint8(4 + 4 + classNameLength + 1 + 4 + instLength + i)\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\t// console.log(\"INST classId:\", classId);\r\n\t\t\t// console.log(\"INST className:\", className);\r\n\t\t\t// console.log(\"INST hasService:\", hasService);\r\n\t\t\t// console.log(\"INST instLength:\", instLength);\r\n\t\t\t// console.log(\"INST instIds:\", instIds);\r\n\t\t\t// console.log(\"INST isService:\", isService);\r\n\r\n\t\t\tclasses[classId] = {\r\n\t\t\t\tclassName,\r\n\t\t\t\tinstances: [],\r\n\t\t\t};\r\n\r\n\t\t\tvar instId = 0;\r\n\t\t\tfor (let i = 0; i < instLength; i++) {\r\n\t\t\t\tinstId += instIds[i];\r\n\t\t\t\tinstances[instId] = { ClassName: className, Children: [] };\r\n\t\t\t\tclasses[classId].instances.push(instId);\r\n\t\t\t}\r\n\t\t} else if (chunk.signature == \"PROP\") {\r\n\t\t\tconst classId = payload.getInt32(0, true);\r\n\t\t\tconst [propName, propNameLength] = (0,_binaryTypeReader__WEBPACK_IMPORTED_MODULE_0__.ReadString)(payload, 4);\r\n\t\t\tconst value = (0,_binaryTypeReader__WEBPACK_IMPORTED_MODULE_0__.ReadPropertyValue)(\r\n\t\t\t\tpayload,\r\n\t\t\t\t4 + 4 + propNameLength,\r\n\t\t\t\tclasses[classId].instances.length\r\n\t\t\t);\r\n\r\n\t\t\tif (value.values) {\r\n\t\t\t\tfor (let i = 0; i < classes[classId].instances.length; i++) {\r\n\t\t\t\t\tconst instId = classes[classId].instances[i];\r\n\t\t\t\t\tinstances[instId][propName] = value.values[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// console.log(\"PROP classId:\", classId);\r\n\t\t\t// console.log(\"PROP propName:\", propName);\r\n\t\t\t// console.log(\"PROP value type:\", value.type);\r\n\t\t\t// console.log(\"PROP values:\", value.values);\r\n\t\t} else if (chunk.signature == \"PRNT\") {\r\n\t\t\tconst assocLength = payload.getUint32(1, true);\r\n\t\t\tconst children = (0,_binaryTypeReader__WEBPACK_IMPORTED_MODULE_0__.ReadReferences)(payload, 5, assocLength);\r\n\t\t\tconst parents = (0,_binaryTypeReader__WEBPACK_IMPORTED_MODULE_0__.ReadReferences)(payload, 5 + assocLength * 4, assocLength);\r\n\r\n\t\t\tvar childId = 0;\r\n\t\t\tvar parentId = 0;\r\n\t\t\tfor (let i = 0; i < assocLength; i++) {\r\n\t\t\t\tchildId += children[i];\r\n\t\t\t\tparentId += parents[i];\r\n\r\n\t\t\t\tconst child = instances[childId];\r\n\r\n\t\t\t\tif (parentId < 0) {\r\n\t\t\t\t\t// console.log(\"PRNT child\", child, childId, \"is root\");\r\n\t\t\t\t\toutput[childId] = child;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconst parent = instances[parentId];\r\n\r\n\t\t\t\t\tparent.Children.push(child);\r\n\r\n\t\t\t\t\t// console.log(\r\n\t\t\t\t\t// \t\"PRNT child\",\r\n\t\t\t\t\t// \tchild,\r\n\t\t\t\t\t// \tchildId,\r\n\t\t\t\t\t// \t\"is child of parent\",\r\n\t\t\t\t\t// \tparent\r\n\t\t\t\t\t// );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// console.log(\"PRNT assocLength:\", assocLength);\r\n\t\t\t// console.log(\"PRNT children:\", children);\r\n\t\t\t// console.log(\"PRNT parents:\", parents);\r\n\t\t}\r\n\t}\r\n\r\n\t// console.log(\"Output:\", output);\r\n\tconsole.log(\r\n\t\t\"Finished decoding file.\\nTime elapsed:\",\r\n\t\tperformance.now() - start,\r\n\t\t\"ms\"\r\n\t);\r\n\r\n\treturn output;\r\n}\r\n\r\n// test\r\n// const testFile = fs.readFileSync(\"test.rbxm\");\r\n// decode(testFile);\r\n\r\n\r\n\n\n//# sourceURL=webpack://rbxbinaryparser/./src/index.js?");

/***/ }),

/***/ "./src/lz4.js":
/*!********************!*\
  !*** ./src/lz4.js ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ LZ4BlockJS)\n/* harmony export */ });\n/*******************************************************************************\r\n\r\n    lz4-block-codec-js.js\r\n        A javascript wrapper around a pure javascript implementation of\r\n        LZ4 block format codec.\r\n    Copyright (C) 2018 Raymond Hill\r\n\r\n    BSD-2-Clause License (http://www.opensource.org/licenses/bsd-license.php)\r\n\r\n    Redistribution and use in source and binary forms, with or without\r\n    modification, are permitted provided that the following conditions are\r\n    met:\r\n\r\n    1. Redistributions of source code must retain the above copyright\r\n    notice, this list of conditions and the following disclaimer.\r\n\r\n    2. Redistributions in binary form must reproduce the above\r\n    copyright notice, this list of conditions and the following disclaimer\r\n    in the documentation and/or other materials provided with the\r\n    distribution.\r\n\r\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\n    Home: https://github.com/gorhill/lz4-wasm\r\n\r\n    I used the same license as the one picked by creator of LZ4 out of respect\r\n    for his creation, see https://lz4.github.io/lz4/\r\n\r\n*/\r\n\r\n\r\n\r\n/******************************************************************************/\r\n\r\n// (function (context) {\r\n// >>>> Start of private namespace\r\n\r\n/******************************************************************************/\r\n\r\nlet growOutputBuffer = function (instance, size) {\r\n\tif (\r\n\t\tinstance.outputBuffer === undefined ||\r\n\t\tinstance.outputBuffer.byteLength < size\r\n\t) {\r\n\t\tinstance.outputBuffer = new ArrayBuffer((size + 0xffff) & 0x7fff0000);\r\n\t}\r\n\treturn instance.outputBuffer;\r\n};\r\n\r\nlet encodeBound = function (size) {\r\n\treturn size > 0x7e000000 ? 0 : size + ((size / 255) | 0) + 16;\r\n};\r\n\r\nlet encodeBlock = function (instance, iBuf, oOffset) {\r\n\tlet iLen = iBuf.byteLength;\r\n\tif (iLen >= 0x7e000000) {\r\n\t\tthrow new RangeError();\r\n\t}\r\n\r\n\t// \"The last match must start at least 12 bytes before end of block\"\r\n\tlet lastMatchPos = iLen - 12;\r\n\r\n\t// \"The last 5 bytes are always literals\"\r\n\tlet lastLiteralPos = iLen - 5;\r\n\r\n\tif (instance.hashTable === undefined) {\r\n\t\tinstance.hashTable = new Int32Array(65536);\r\n\t}\r\n\tinstance.hashTable.fill(-65536);\r\n\r\n\tif (iBuf instanceof ArrayBuffer) {\r\n\t\tiBuf = new Uint8Array(iBuf);\r\n\t}\r\n\r\n\tlet oLen = oOffset + encodeBound(iLen);\r\n\tlet oBuf = new Uint8Array(growOutputBuffer(instance, oLen), 0, oLen);\r\n\tlet iPos = 0;\r\n\tlet oPos = oOffset;\r\n\tlet anchorPos = 0;\r\n\r\n\t// sequence-finding loop\r\n\tfor (;;) {\r\n\t\tlet refPos;\r\n\t\tlet mOffset;\r\n\t\tlet sequence =\r\n\t\t\t(iBuf[iPos] << 8) | (iBuf[iPos + 1] << 16) | (iBuf[iPos + 2] << 24);\r\n\r\n\t\t// match-finding loop\r\n\t\twhile (iPos <= lastMatchPos) {\r\n\t\t\tsequence = (sequence >>> 8) | (iBuf[iPos + 3] << 24);\r\n\t\t\tlet hash =\r\n\t\t\t\t(((sequence * 0x9e37) & 0xffff) + ((sequence * 0x79b1) >>> 16)) &\r\n\t\t\t\t0xffff;\r\n\t\t\trefPos = instance.hashTable[hash];\r\n\t\t\tinstance.hashTable[hash] = iPos;\r\n\t\t\tmOffset = iPos - refPos;\r\n\t\t\tif (\r\n\t\t\t\tmOffset < 65536 &&\r\n\t\t\t\tiBuf[refPos + 0] === (sequence & 0xff) &&\r\n\t\t\t\tiBuf[refPos + 1] === ((sequence >>> 8) & 0xff) &&\r\n\t\t\t\tiBuf[refPos + 2] === ((sequence >>> 16) & 0xff) &&\r\n\t\t\t\tiBuf[refPos + 3] === ((sequence >>> 24) & 0xff)\r\n\t\t\t) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tiPos += 1;\r\n\t\t}\r\n\r\n\t\t// no match found\r\n\t\tif (iPos > lastMatchPos) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t// match found\r\n\t\tlet lLen = iPos - anchorPos;\r\n\t\tlet mLen = iPos;\r\n\t\tiPos += 4;\r\n\t\trefPos += 4;\r\n\t\twhile (iPos < lastLiteralPos && iBuf[iPos] === iBuf[refPos]) {\r\n\t\t\tiPos += 1;\r\n\t\t\trefPos += 1;\r\n\t\t}\r\n\t\tmLen = iPos - mLen;\r\n\t\tlet token = mLen < 19 ? mLen - 4 : 15;\r\n\r\n\t\t// write token, length of literals if needed\r\n\t\tif (lLen >= 15) {\r\n\t\t\toBuf[oPos++] = 0xf0 | token;\r\n\t\t\tlet l = lLen - 15;\r\n\t\t\twhile (l >= 255) {\r\n\t\t\t\toBuf[oPos++] = 255;\r\n\t\t\t\tl -= 255;\r\n\t\t\t}\r\n\t\t\toBuf[oPos++] = l;\r\n\t\t} else {\r\n\t\t\toBuf[oPos++] = (lLen << 4) | token;\r\n\t\t}\r\n\r\n\t\t// write literals\r\n\t\twhile (lLen--) {\r\n\t\t\toBuf[oPos++] = iBuf[anchorPos++];\r\n\t\t}\r\n\r\n\t\tif (mLen === 0) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t// write offset of match\r\n\t\toBuf[oPos + 0] = mOffset;\r\n\t\toBuf[oPos + 1] = mOffset >>> 8;\r\n\t\toPos += 2;\r\n\r\n\t\t// write length of match if needed\r\n\t\tif (mLen >= 19) {\r\n\t\t\tlet l = mLen - 19;\r\n\t\t\twhile (l >= 255) {\r\n\t\t\t\toBuf[oPos++] = 255;\r\n\t\t\t\tl -= 255;\r\n\t\t\t}\r\n\t\t\toBuf[oPos++] = l;\r\n\t\t}\r\n\r\n\t\tanchorPos = iPos;\r\n\t}\r\n\r\n\t// last sequence is literals only\r\n\tlet lLen = iLen - anchorPos;\r\n\tif (lLen >= 15) {\r\n\t\toBuf[oPos++] = 0xf0;\r\n\t\tlet l = lLen - 15;\r\n\t\twhile (l >= 255) {\r\n\t\t\toBuf[oPos++] = 255;\r\n\t\t\tl -= 255;\r\n\t\t}\r\n\t\toBuf[oPos++] = l;\r\n\t} else {\r\n\t\toBuf[oPos++] = lLen << 4;\r\n\t}\r\n\twhile (lLen--) {\r\n\t\toBuf[oPos++] = iBuf[anchorPos++];\r\n\t}\r\n\r\n\treturn new Uint8Array(oBuf.buffer, 0, oPos);\r\n};\r\n\r\nlet decodeBlock = function (instance, iBuf, iOffset, oLen) {\r\n\tlet iLen = iBuf.byteLength;\r\n\tlet oBuf = new Uint8Array(growOutputBuffer(instance, oLen), 0, oLen);\r\n\tlet iPos = iOffset,\r\n\t\toPos = 0;\r\n\r\n\twhile (iPos < iLen) {\r\n\t\tlet token = iBuf[iPos++];\r\n\r\n\t\t// literals\r\n\t\tlet clen = token >>> 4;\r\n\r\n\t\t// length of literals\r\n\t\tif (clen !== 0) {\r\n\t\t\tif (clen === 15) {\r\n\t\t\t\tlet l;\r\n\t\t\t\tfor (;;) {\r\n\t\t\t\t\tl = iBuf[iPos++];\r\n\t\t\t\t\tif (l !== 255) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tclen += 255;\r\n\t\t\t\t}\r\n\t\t\t\tclen += l;\r\n\t\t\t}\r\n\r\n\t\t\t// copy literals\r\n\t\t\tlet end = iPos + clen;\r\n\t\t\twhile (iPos < end) {\r\n\t\t\t\toBuf[oPos++] = iBuf[iPos++];\r\n\t\t\t}\r\n\t\t\tif (iPos === iLen) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// match\r\n\t\tlet mOffset = iBuf[iPos + 0] | (iBuf[iPos + 1] << 8);\r\n\t\tif (mOffset === 0 || mOffset > oPos) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tiPos += 2;\r\n\r\n\t\t// length of match\r\n\t\tclen = (token & 0x0f) + 4;\r\n\t\tif (clen === 19) {\r\n\t\t\tlet l;\r\n\t\t\tfor (;;) {\r\n\t\t\t\tl = iBuf[iPos++];\r\n\t\t\t\tif (l !== 255) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tclen += 255;\r\n\t\t\t}\r\n\t\t\tclen += l;\r\n\t\t}\r\n\r\n\t\t// copy match\r\n\t\tlet mPos = oPos - mOffset;\r\n\t\tlet end = oPos + clen;\r\n\t\twhile (oPos < end) {\r\n\t\t\toBuf[oPos++] = oBuf[mPos++];\r\n\t\t}\r\n\t}\r\n\r\n\treturn oBuf;\r\n};\r\n\r\n/******************************************************************************/\r\n\r\nfunction LZ4BlockJS() {\r\n\tthis.hashTable = undefined;\r\n\tthis.outputBuffer = undefined;\r\n}\r\n\r\nLZ4BlockJS.prototype = {\r\n\tflavor: \"js\",\r\n\tinit: function () {\r\n\t\treturn Promise.resolve();\r\n\t},\r\n\r\n\treset: function () {\r\n\t\tthis.hashTable = undefined;\r\n\t\tthis.outputBuffer = undefined;\r\n\t},\r\n\r\n\tbytesInUse: function () {\r\n\t\tlet bytesInUse = 0;\r\n\t\tif (this.hashTable !== undefined) {\r\n\t\t\tbytesInUse += this.hashTable.byteLength;\r\n\t\t}\r\n\t\tif (this.outputBuffer !== undefined) {\r\n\t\t\tbytesInUse += this.outputBuffer.byteLength;\r\n\t\t}\r\n\t\treturn bytesInUse;\r\n\t},\r\n\r\n\tencodeBlock: function (input, outputOffset) {\r\n\t\tif (input instanceof ArrayBuffer) {\r\n\t\t\tinput = new Uint8Array(input);\r\n\t\t} else if (input instanceof Uint8Array === false) {\r\n\t\t\tthrow new TypeError();\r\n\t\t}\r\n\t\treturn encodeBlock(this, input, outputOffset);\r\n\t},\r\n\r\n\tdecodeBlock: function (input, inputOffset, outputSize) {\r\n\t\tif (input instanceof ArrayBuffer) {\r\n\t\t\tinput = new Uint8Array(input);\r\n\t\t} else if (input instanceof Uint8Array === false) {\r\n\t\t\tthrow new TypeError();\r\n\t\t}\r\n\t\treturn decodeBlock(this, input, inputOffset, outputSize);\r\n\t},\r\n};\r\n\r\n/******************************************************************************/\r\n// })(this || self); // <<<< End of private namespace\r\n\r\n/******************************************************************************/\r\n\n\n//# sourceURL=webpack://rbxbinaryparser/./src/lz4.js?");

/***/ }),

/***/ "./src/util.js":
/*!*********************!*\
  !*** ./src/util.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"arraysEqual\": () => (/* binding */ arraysEqual)\n/* harmony export */ });\n/**\r\n * Checks if two arrays are equal\r\n * @param {Array} a\r\n * @param {Array} b\r\n * @returns\r\n */\r\nfunction arraysEqual(a, b) {\r\n\tif (a.length == b.length) {\r\n\t\ta.forEach((v, i) => {\r\n\t\t\tif (v != b[i]) return false;\r\n\t\t});\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n\n\n//# sourceURL=webpack://rbxbinaryparser/./src/util.js?");

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
/******/ 
/******/ // startup
/******/ // Load entry module and return exports
/******/ // This entry module can't be inlined because the eval devtool is used.
/******/ var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ var __webpack_exports__decode = __webpack_exports__.decode;
/******/ export { __webpack_exports__decode as decode };
/******/ 
